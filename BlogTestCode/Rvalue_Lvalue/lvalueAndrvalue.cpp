int rtnInt() { return 1; }
int& refInt() {
    static int a = 10;
    return a;
}
int* rtnPtr()
{
    static int a = 10;
    return &a;
}

int main() {
    // 1. 변수: 변수는 메모리 상에 위치가 있고 참조할 수 있으므로 lvalue입니다.
    // 2. 리터럴: 리터럴은 컴파일 타임에 결정되는 상수이므로 메모리 상에 명확한 위치가 없는 prvalue입니다.
    int a = 10;

    // 3. 배열 요소: 배열의 각 요소는 메모리 상에 위치가 있고 참조할 수 있으므로 lvalue입니다.
    int arr[5];
    arr[0] = 1;
    // 4. 배열 이름: 다만, 배열의 이름은 배열의 첫 번째 요소의 주소로 사용되는 prvalue입니다.
    int* p = arr;

    // 5. 포인터 참조: 포인터 참조 연산자(&)는 변수의 주소를 가져오는 rvalue입니다.
    // 6. 포인터 역참조: 포인터 역참조(*)는 메모리 상의 위치를 가리키는 lvalue입니다.
    int* ptr = &a;
    *ptr = 30;

    // 7. 비참조 타입을 반환하는 함수: 비참조 타입을 반환하는 함수의 반환값은 prvalue입니다.
    int num = rtnInt();

    // 8. 참조나 포인터를 반환하는 함수: 참조나 포인터를 반환하는 함수의 반환값은 lvalue입니다.
    refInt() = 20;
    *rtnPtr() = 20;

    // 9. 멤버 접근 연산자(.): 객체의 멤버에 대한 접근도 lvalue입니다.
    struct MyStruct
	{
        int x;
    };
    MyStruct myStruct;
    myStruct.x = 50;

    // 10. 전위 증감 연산자: 전위 증감 연산자는 변수의 값을 증감시키고 그 값을 반환합니다. 따라서 변수 그 자체로 반환하면 되기 때문에 lvalue입니다.
    ++a = 10;
    --a = 20;

    // 11. 후위 증감 연산자: 후위 증감 연산자는 변수의 현재 값을 임시로 저장한 후, 변수의 값을 증가시키거나 감소시킵니다. 그리고 임시로 저장한 원래 값을 반환합니다.
    // 따라서, 임시로 저장한 값을 반환하기 때문에 rvalue입니다.
    arr[1] = a++;

    // 12. 람다 표현식: 람다 표현식은 이름이 없는 임시 함수 객체를 생성하므로 prvalue입니다.
    auto lambda = []() { return 42; };

    // 13. 캐스팅 연산: 캐스팅 연산의 결과는 대부분 rvalue입니다.
    // 캐스팅 연산은 기존 변수의 값을 새로운 타입으로 변환하여 임시 값을 생성하고 새로운 변수에 저장하는 경우가 많기 때문입니다.
    double e = static_cast<double>(a);  // a의 값을 double로 변환하여 그 값을 e에 저장.

    // 14. 삼항 연산자: 삼항 연산자의 경우에는 결과에 따라 lvalue와 prvalue가 혼재할 수 있습니다.
    int d = (a > 0) ? a : 42;  // (a > 0) ? a : 42는 prvalue (a가 lvalue이지만 42가 prvalue이므로)
    (a > 0) ? a : d = 42;      // (a > 0) ? a : d = 42는 어떤 결과가 나와도 lvalue (a와 d가 모두 lvalue이므로)

}